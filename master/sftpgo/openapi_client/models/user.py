# -*- coding: utf-8 -*-

"""
    SFTPGo

    SFTPGo allows you to securely share your files over SFTP and optionally over HTTP/S, FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per-user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, a user with the S3 backend mapping a Google Cloud Storage bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo supports groups to simplify the administration of multiple accounts by letting you assign settings once to a group, instead of multiple times to each individual user. The SFTPGo WebClient allows end users to change their credentials, browse and manage their files in the browser and setup two-factor authentication which works with Authy, Google Authenticator and other compatible apps. From the WebClient each authorized user can also create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date.

    The version of the OpenAPI document: 2.5.6
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import (
    BaseModel,
    Field,
    SecretStr,
    StrictBool,
    StrictInt,
    StrictStr,
    conint,
    conlist,
    validator,
)
from openapi_client.models.filesystem_config import FilesystemConfig
from openapi_client.models.group_mapping import GroupMapping
from openapi_client.models.permission import Permission
from openapi_client.models.user_filters import UserFilters
from openapi_client.models.virtual_folder import VirtualFolder


class User(BaseModel):
    """
    User
    """

    id: Optional[conint(strict=True, ge=1)] = None
    status: Optional[StrictInt] = Field(
        None,
        description="status:   * `0` user is disabled, login is not allowed   * `1` user is enabled ",
    )
    username: Optional[StrictStr] = Field(None, description="username is unique")
    email: Optional[StrictStr] = None
    description: Optional[StrictStr] = Field(
        None, description="optional description, for example the user full name"
    )
    expiration_date: Optional[StrictInt] = Field(
        None,
        description="expiration date as unix timestamp in milliseconds. An expired account cannot login. 0 means no expiration",
    )
    password: Optional[SecretStr] = Field(
        None,
        description="If the password has no known hashing algo prefix it will be stored, by default, using bcrypt, argon2id is supported too. You can send a password hashed as bcrypt ($2a$ prefix), argon2id, pbkdf2 or unix crypt and it will be stored as is. For security reasons this field is omitted when you search/get users",
    )
    public_keys: Optional[conlist(StrictStr)] = Field(
        None, description="Public keys in OpenSSH format."
    )
    has_password: Optional[StrictBool] = Field(
        None, description="Indicates whether the password is set"
    )
    home_dir: Optional[StrictStr] = Field(
        None,
        description="path to the user home directory. The user cannot upload or download files outside this directory. SFTPGo tries to automatically create this folder if missing. Must be an absolute path",
    )
    virtual_folders: Optional[conlist(VirtualFolder)] = Field(
        None,
        description="mapping between virtual SFTPGo paths and virtual folders. If one or more of the specified folders are not inside the dataprovider they will be automatically created. You have to create the folder on the filesystem yourself",
    )
    uid: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(
        None,
        description="if you run SFTPGo as root user, the created files and directories will be assigned to this uid. 0 means no change, the owner will be the user that runs SFTPGo. Ignored on windows",
    )
    gid: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(
        None,
        description="if you run SFTPGo as root user, the created files and directories will be assigned to this gid. 0 means no change, the group will be the one of the user that runs SFTPGo. Ignored on windows",
    )
    max_sessions: Optional[StrictInt] = Field(
        None, description="Limit the sessions that a user can open. 0 means unlimited"
    )
    quota_size: Optional[StrictInt] = Field(
        None,
        description="Quota as size in bytes. 0 means unlimited. Please note that quota is updated if files are added/removed via SFTPGo otherwise a quota scan or a manual quota update is needed",
    )
    quota_files: Optional[StrictInt] = Field(
        None,
        description="Quota as number of files. 0 means unlimited. Please note that quota is updated if files are added/removed via SFTPGo otherwise a quota scan or a manual quota update is needed",
    )
    permissions: Optional[Dict[str, conlist(Permission, min_items=1)]] = Field(
        None,
        description='hash map with directory as key and an array of permissions as value. Directories must be absolute paths, permissions for root directory ("/") are required',
    )
    used_quota_size: Optional[StrictInt] = None
    used_quota_files: Optional[StrictInt] = None
    last_quota_update: Optional[StrictInt] = Field(
        None, description="Last quota update as unix timestamp in milliseconds"
    )
    upload_bandwidth: Optional[StrictInt] = Field(
        None, description="Maximum upload bandwidth as KB/s, 0 means unlimited"
    )
    download_bandwidth: Optional[StrictInt] = Field(
        None, description="Maximum download bandwidth as KB/s, 0 means unlimited"
    )
    upload_data_transfer: Optional[StrictInt] = Field(
        None,
        description="Maximum data transfer allowed for uploads as MB. 0 means no limit",
    )
    download_data_transfer: Optional[StrictInt] = Field(
        None,
        description="Maximum data transfer allowed for downloads as MB. 0 means no limit",
    )
    total_data_transfer: Optional[StrictInt] = Field(
        None,
        description="Maximum total data transfer as MB. 0 means unlimited. You can set a total data transfer instead of the individual values for uploads and downloads",
    )
    used_upload_data_transfer: Optional[StrictInt] = Field(
        None, description="Uploaded size, as bytes, since the last reset"
    )
    used_download_data_transfer: Optional[StrictInt] = Field(
        None, description="Downloaded size, as bytes, since the last reset"
    )
    created_at: Optional[StrictInt] = Field(
        None,
        description="creation time as unix timestamp in milliseconds. It will be 0 for users created before v2.2.0",
    )
    updated_at: Optional[StrictInt] = Field(
        None, description="last update time as unix timestamp in milliseconds"
    )
    last_login: Optional[StrictInt] = Field(
        None,
        description="Last user login as unix timestamp in milliseconds. It is saved at most once every 10 minutes",
    )
    first_download: Optional[StrictInt] = Field(
        None, description="first download time as unix timestamp in milliseconds"
    )
    first_upload: Optional[StrictInt] = Field(
        None, description="first upload time as unix timestamp in milliseconds"
    )
    last_password_change: Optional[StrictInt] = Field(
        None, description="last password change time as unix timestamp in milliseconds"
    )
    filters: Optional[UserFilters] = None
    filesystem: Optional[FilesystemConfig] = None
    additional_info: Optional[StrictStr] = Field(
        None, description="Free form text field for external systems"
    )
    groups: Optional[conlist(GroupMapping)] = None
    oidc_custom_fields: Optional[Dict[str, Any]] = Field(
        None,
        description="This field is passed to the pre-login hook if custom OIDC token fields have been configured. Field values can be of any type (this is a free form object) and depend on the type of the configured OIDC token fields",
    )
    role: Optional[StrictStr] = None
    __properties = [
        "id",
        "status",
        "username",
        "email",
        "description",
        "expiration_date",
        "password",
        "public_keys",
        "has_password",
        "home_dir",
        "virtual_folders",
        "uid",
        "gid",
        "max_sessions",
        "quota_size",
        "quota_files",
        "permissions",
        "used_quota_size",
        "used_quota_files",
        "last_quota_update",
        "upload_bandwidth",
        "download_bandwidth",
        "upload_data_transfer",
        "download_data_transfer",
        "total_data_transfer",
        "used_upload_data_transfer",
        "used_download_data_transfer",
        "created_at",
        "updated_at",
        "last_login",
        "first_download",
        "first_upload",
        "last_password_change",
        "filters",
        "filesystem",
        "additional_info",
        "groups",
        "oidc_custom_fields",
        "role",
    ]

    @validator("status")
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in (0, 1):
            raise ValueError("must be one of enum values (0, 1)")
        return value

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> User:
        """Create an instance of User from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in virtual_folders (list)
        _items = []
        if self.virtual_folders:
            for _item in self.virtual_folders:
                if _item:
                    _items.append(_item.to_dict())
            _dict["virtual_folders"] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in permissions (dict of array)
        _field_dict_of_array = {}
        if self.permissions:
            for _key in self.permissions:
                if self.permissions[_key]:
                    _field_dict_of_array[_key] = [
                        _item.to_dict() for _item in self.permissions[_key]
                    ]
            _dict["permissions"] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of filters
        if self.filters:
            _dict["filters"] = self.filters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of filesystem
        if self.filesystem:
            _dict["filesystem"] = self.filesystem.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in groups (list)
        _items = []
        if self.groups:
            for _item in self.groups:
                if _item:
                    _items.append(_item.to_dict())
            _dict["groups"] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> User:
        """Create an instance of User from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return User.parse_obj(obj)

        _obj = User.parse_obj(
            {
                "id": obj.get("id"),
                "status": obj.get("status"),
                "username": obj.get("username"),
                "email": obj.get("email"),
                "description": obj.get("description"),
                "expiration_date": obj.get("expiration_date"),
                "password": obj.get("password"),
                "public_keys": obj.get("public_keys"),
                "has_password": obj.get("has_password"),
                "home_dir": obj.get("home_dir"),
                "virtual_folders": [
                    VirtualFolder.from_dict(_item)
                    for _item in obj.get("virtual_folders")
                ]
                if obj.get("virtual_folders") is not None
                else None,
                "uid": obj.get("uid"),
                "gid": obj.get("gid"),
                "max_sessions": obj.get("max_sessions"),
                "quota_size": obj.get("quota_size"),
                "quota_files": obj.get("quota_files"),
                "permissions": dict(
                    (
                        _k,
                        [Permission.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None,
                    )
                    for _k, _v in obj.get("permissions").items()
                ),
                "used_quota_size": obj.get("used_quota_size"),
                "used_quota_files": obj.get("used_quota_files"),
                "last_quota_update": obj.get("last_quota_update"),
                "upload_bandwidth": obj.get("upload_bandwidth"),
                "download_bandwidth": obj.get("download_bandwidth"),
                "upload_data_transfer": obj.get("upload_data_transfer"),
                "download_data_transfer": obj.get("download_data_transfer"),
                "total_data_transfer": obj.get("total_data_transfer"),
                "used_upload_data_transfer": obj.get("used_upload_data_transfer"),
                "used_download_data_transfer": obj.get("used_download_data_transfer"),
                "created_at": obj.get("created_at"),
                "updated_at": obj.get("updated_at"),
                "last_login": obj.get("last_login"),
                "first_download": obj.get("first_download"),
                "first_upload": obj.get("first_upload"),
                "last_password_change": obj.get("last_password_change"),
                "filters": UserFilters.from_dict(obj.get("filters"))
                if obj.get("filters") is not None
                else None,
                "filesystem": FilesystemConfig.from_dict(obj.get("filesystem"))
                if obj.get("filesystem") is not None
                else None,
                "additional_info": obj.get("additional_info"),
                "groups": [GroupMapping.from_dict(_item) for _item in obj.get("groups")]
                if obj.get("groups") is not None
                else None,
                "oidc_custom_fields": obj.get("oidc_custom_fields"),
                "role": obj.get("role"),
            }
        )
        return _obj
